"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[205],{1174:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/merging_deformed_abc_with_blendshape-3f5539c003dcaeb5fbcbcf6f65a40dd0.png"},1470:(e,n,t)=>{t.d(n,{A:()=>k});var a=t(6540),r=t(4164),o=t(3104),s=t(6347),i=t(205),d=t(7485),c=t(1682),l=t(679);function u(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function m(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return u(e).map((({props:{value:e,label:n,attributes:t,default:a}})=>({value:e,label:n,attributes:t,default:a})))}(t);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,t])}function p({value:e,tabValues:n}){return n.some((n=>n.value===e))}function h({queryString:e=!1,groupId:n}){const t=(0,s.W6)(),r=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,d.aZ)(r),(0,a.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(t.location.search);n.set(r,e),t.replace({...t.location,search:n.toString()})}),[r,t])]}function _(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,o=m(e),[s,d]=(0,a.useState)((()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!p({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const t=n.find((e=>e.default))??n[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:o}))),[c,u]=h({queryString:t,groupId:r}),[_,b]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[t,r]=(0,l.Dv)(n);return[t,(0,a.useCallback)((e=>{n&&r.set(e)}),[n,r])]}({groupId:r}),f=(()=>{const e=c??_;return p({value:e,tabValues:o})?e:null})();(0,i.A)((()=>{f&&d(f)}),[f]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);d(e),u(e),b(e)}),[u,b,o]),tabValues:o}}var b=t(2303);const f={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=t(4848);function y({className:e,block:n,selectedValue:t,selectValue:a,tabValues:s}){const i=[],{blockElementScrollPositionUntilNextRender:d}=(0,o.a_)(),c=e=>{const n=e.currentTarget,r=i.indexOf(n),o=s[r].value;o!==t&&(d(n),a(o))},l=e=>{let n=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const t=i.indexOf(e.currentTarget)+1;n=i[t]??i[0];break}case"ArrowLeft":{const t=i.indexOf(e.currentTarget)-1;n=i[t]??i[i.length-1];break}}n?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":n},e),children:s.map((({value:e,label:n,attributes:a})=>(0,g.jsx)("li",{role:"tab",tabIndex:t===e?0:-1,"aria-selected":t===e,ref:e=>{i.push(e)},onKeyDown:l,onClick:c,...a,className:(0,r.A)("tabs__item",f.tabItem,a?.className,{"tabs__item--active":t===e}),children:n??e},e)))})}function x({lazy:e,children:n,selectedValue:t}){const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=o.find((e=>e.props.value===t));return e?(0,a.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==t})))})}function v(e){const n=_(e);return(0,g.jsxs)("div",{className:(0,r.A)("tabs-container",f.tabList),children:[(0,g.jsx)(y,{...n,...e}),(0,g.jsx)(x,{...n,...e})]})}function k(e){const n=(0,b.A)();return(0,g.jsx)(v,{...e,children:u(e.children)},String(n))}},3587:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/merging_transformed_abc-e5c372cf715c4603c59074ecd04fee1c.png"},6026:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/transforms_curves_only-17e29ede1850b45f251632edbab766f1.png"},7508:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"developer/advanced_scripts/pipeline_alembics_from_tangerine","title":"Exports from Tangerine to Maya Pipeline","description":"To maximize efficiency, it makes sense to separate steps as much as possible, reducing dependencies between them.","source":"@site/docs/developer/advanced_scripts/pipeline_alembics_from_tangerine.md","sourceDirName":"developer/advanced_scripts","slug":"/developer/advanced_scripts/pipeline_alembics_from_tangerine","permalink":"/tangerine-docs/developer/advanced_scripts/pipeline_alembics_from_tangerine","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Callback Processes","permalink":"/tangerine-docs/developer/advanced_scripts/callback_usecase"},"next":{"title":"Playblast HUD","permalink":"/tangerine-docs/developer/advanced_scripts/playblast_hud"}}');var r=t(4848),o=t(8453);t(1470),t(9365);const s={sidebar_position:3},i="Exports from Tangerine to Maya Pipeline",d={},c=[{value:"Exporting usefull and optimised data for pipeline chain",id:"exporting-usefull-and-optimised-data-for-pipeline-chain",level:2},{value:"Bake abc for parts of asset for external software",id:"bake-abc-for-parts-of-asset-for-external-software",level:3},{value:"Build you maya scene",id:"build-you-maya-scene",level:2},{value:"Add Preroll and Postroll Before Export",id:"add-preroll-and-postroll-before-export",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{Details:a}=n;return a||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"exports-from-tangerine-to-maya-pipeline",children:"Exports from Tangerine to Maya Pipeline"})}),"\n",(0,r.jsx)(n.p,{children:"To maximize efficiency, it makes sense to separate steps as much as possible, reducing dependencies between them.\nFor example, surfacing and UVs for rendering are generally independent of animation (except for animated UV features)."}),"\n",(0,r.jsx)(n.p,{children:'Here is a workflow to keep these steps independent: import the "renderable" version of an asset (UVs, shaders) into Maya and merge it in a controlled way with an Alembic file exported from Tangerine.'}),"\n",(0,r.jsx)(n.h2,{id:"exporting-usefull-and-optimised-data-for-pipeline-chain",children:"Exporting usefull and optimised data for pipeline chain"}),"\n",(0,r.jsx)(n.p,{children:"Here is an example of connected the exported alembic into maya.\nThis in not the only way to do it, you would prefer another strategy depending on your pipeline."}),"\n",(0,r.jsxs)(n.p,{children:["Export sample :\n",(0,r.jsx)(n.code,{children:"transforms"})," : contains only values and values lists on transforms node. Will concern only not deformed (bake on vertex) animations.\n",(0,r.jsx)(n.code,{children:"all"})," : contains all animations, deformations on meshs and transforms animations.\n",(0,r.jsx)(n.code,{children:"onlyDeformed"})," : contains transforms animations and meshs that have been deformed in the shot. Usefull to optimise alembic size, for example on sets."]}),"\n",(0,r.jsx)(n.h3,{id:"bake-abc-for-parts-of-asset-for-external-software",children:"Bake abc for parts of asset for external software"}),"\n",(0,r.jsx)(n.p,{children:"First exports alembic files with custom content using tags"}),"\n",(0,r.jsxs)(a,{children:[(0,r.jsx)("summary",{children:"Command sample exports"}),(0,r.jsxs)(n.p,{children:["This sample code is based on scene ",(0,r.jsx)(n.code,{children:"three_capy.shot"})," available in demo package.\nWe focus on two assets, ",(0,r.jsx)(n.code,{children:"character_n01_jb:jb"})," and ",(0,r.jsx)(n.code,{children:"prop_n01_yuzu_logo:yuzu_logo"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'from tang_core.document.get_document import get_document\n\nfrom meta_nodal_py import SceneGraphNode, Geometry, SplineCurve\ndef get_all_hierarchy(node, node_type=None):\n        result = []\n        if node_type == "mesh":\n            class_instance = Geometry\n        elif node_type == "spline":\n            class_instance = SplineCurve\n        elif not node_type == "group":\n            class_instance = SceneGraphNode\n        else:\n            class_instance = None\n\n        for it in node.depth_first_skippable_iterator():\n            node = it.node\n            if not isinstance(node, SceneGraphNode) and not isinstance(node, class_instance):\n                it.skip_children()\n            elif (class_instance is not None and isinstance(node, class_instance)):\n                result.append(node)\n        return result\n\ndef set_bake_tag_on_node(bake, node, tagger=None):\n    """Helper function to set the :param node: tags "do_bake" and "do_not_bake" according to the :param bakable:\n    Perform tag existence check before tagging or untagging.\n    if you intend to use this method on a lot of nodes, please provide a tagger with the tags "do_bake" and\n        "do_not bake" already created, for performance reasons.\n\n    :param bake: Wether the node shall be tagged bakable or not.\n    :type bake: bool\n    :param node: Tangerine node instance to change tags\n    :type node: Node\n    :param tagger: Tagger instance to avoid create a new one each time, defaults to None\n    :type tagger: Tagger, Optional\n    """\n\n    if not tagger:\n        tagger = get_document().tagger\n        tagger.create_tag("do_not_bake", show_in_gui=False)\n        tagger.create_tag("do_bake", show_in_gui=False)\n\n    if bake:\n        if not tagger.has_tag("do_bake", node):\n            tagger.tag_node("do_bake", node)\n        if tagger.has_tag("do_not_bake", node):\n            tagger.untag_node("do_not_bake", node)\n    else:\n        if tagger.has_tag("do_bake", node):\n            tagger.untag_node("do_bake", node)\n        if not tagger.has_tag("do_not_bake", node):\n            tagger.tag_node("do_not_bake", node)\n'})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'from meta_nodal_py import Geometry, DisplayNode, Camera, CrossShapeTool\nfrom tang_core.abc import is_geom_mesh_modified_from_abc_source, AbcFilesKeepOpen\nfrom tang_core.document.get_document import get_document\nfrom tang_core.bake import bake\n\ndocument = get_document()\n\ncapy_jb_asset_node = document.root().find("character_n01_jb:jb")\nyuzu_asset_node = document.root().find("prop_n01_yuzu_logo:yuzu_logo")\nnodes = [capy_jb_asset_node, yuzu_asset_node]\n\ntagger = document.tagger\ntagger.create_tag("do_not_bake", show_in_gui=False)\ntagger.create_tag("do_bake", show_in_gui=False)\n\ndeformed_geometry_nodes = []\nall_geometry_children = []\nnot_geo_transforms_hierarchy = []\n\nwith AbcFilesKeepOpen(document) as abc_files_keep_open:\n    for node in nodes:\n        nothing_to_bake = True\n        for node in node.get_children():\n            # disable bake on every part of rig without geometry. Clean and optimize exported alembic files.\n            if not node.get_name() == "geo":\n                set_bake_tag_on_node(False, node, tagger)\n                continue\n\n            # Get only the "geo" children, to filter parsing on geometry in this sample.\n            geo_children = get_all_hierarchy(node, node_type="mesh")\n            for child in geo_children:\n                all_geometry_children.append(child)\n                if isinstance(child, Geometry):\n                    try:\n                        if is_geom_mesh_modified_from_abc_source(child, abc_files_keep_open):\n                            deformed_geometry_nodes.append(child)\n                    except TangValueError as err:\n                        # If the node is a Locator, an exception is also raised,\n                        input_plug = child.mesh_in.get_plug_input()\n                        if input_plug and isinstance(input_plug.get_node(), CrossShapeTool):\n                            print("Ignoring locator %s", child.get_name())\n\n\n# if you need to export spline, add a bake tag. By default, not baked.\n# for node in nodes:\n#     children = getAllHierarchy(node, nodeType="spline")\n\nabc_export_folder = "E:/TEMP/Tangerine/Tangerine Demo 2025/api_samples/abc_export_usecase/"\n\n# First export, we want only transforms in the hierarchy of "geo" node\nfor node in all_geometry_children:\n    print(node.get_full_name())\n    set_bake_tag_on_node(False, node, tagger) # we add a tag on do_not_bake that we will use as a filter in bake abc file\n\ntry:\n    bake(\n        filename=abc_export_folder + "character_n01_jb_transforms.abc",\n        exclude_tag="do_not_bake",\n        included_spline_tag="do_bake",\n        roots=[capy_jb_asset_node],\n        write_uv=True, # possible to disblae uv writing\n        document=document,\n        sub_samples=[],\n        write_full_matrix=True,\n        start_frame= 1,\n        end_frame= document.end_frame,\n    )\nexcept AttributeError:\n    print(\n        "Error exporting node %s, please check the hierarchy", str([node.get_name() for node in nodes])\n    )\n\ntry:\n    bake(\n        filename=abc_export_folder + "prop_n01_yuzu_logo_transforms.abc",\n        exclude_tag="do_not_bake",\n        included_spline_tag="do_bake",\n        roots=[yuzu_asset_node],\n        write_uv=True, # possible to disblae uv writing\n        document=document,\n        sub_samples=[],\n        write_full_matrix=True,\n        start_frame= 1,\n        end_frame= document.end_frame,\n    )\nexcept AttributeError:\n    print(\n        "Error exporting node %s, please check the hierarchy", str([node.get_name() for node in nodes])\n    )\n\n# Second export only deformed mesh for jb capy\nfor node in deformed_geometry_nodes:\n    # other geometry still have the do_not_bake_tag.\n    set_bake_tag_on_node(True, node, tagger) # we add a tag on do_not_bake that we will use as a filter in bake abc file\n\ntry:\n    bake(\n        filename=abc_export_folder + "character_n01_jb_onlydeformed.abc",\n        exclude_tag="do_not_bake",\n        included_spline_tag="do_bake",\n        roots=[capy_jb_asset_node],\n        write_uv=True, # possible to disblae uv writing\n        document=document,\n        sub_samples=[],\n        write_full_matrix=True,\n        start_frame= 1,\n        end_frame= document.end_frame,\n    )\nexcept AttributeError:\n    print(\n        "Error exporting node %s, please check the hierarchy", str([node.get_name() for node in nodes])\n    )\n# Third export all nodes in geometry\nfor node in all_geometry_children:\n    # other geometry still have the do_not_bake_tag.\n    set_bake_tag_on_node(True, node, tagger) # we add a tag on do_not_bake that we will use as a filter in bake abc file\n\ntry:\n    bake(\n        filename=abc_export_folder + "character_n01_jb_all.abc",\n        exclude_tag="do_not_bake",\n        included_spline_tag="do_bake",\n        roots=[capy_jb_asset_node],\n        write_uv=True, # possible to disblae uv writing\n        document=document,\n        sub_samples=[],\n        write_full_matrix=True,\n        start_frame= 1,\n        end_frame= document.end_frame,\n    )\nexcept AttributeError:\n    print(\n        "Error exporting node %s, please check the hierarchy", str([node.get_name() for node in nodes])\n    )\n\ntry:\n    bake(\n        filename=abc_export_folder + "prop_n01_yuzu_logo_all.abc",\n        exclude_tag="do_not_bake",\n        included_spline_tag="do_bake",\n        roots=[yuzu_asset_node],\n        write_uv=True, # possible to disblae uv writing\n        document=document,\n        sub_samples=[],\n        write_full_matrix=True,\n        start_frame= 1,\n        end_frame= document.end_frame,\n    )\nexcept AttributeError:\n    print(\n        "Error exporting node %s, please check the hierarchy", str([node.get_name() for node in nodes])\n    )\n'})})]}),"\n",(0,r.jsx)(n.h2,{id:"build-you-maya-scene",children:"Build you maya scene"}),"\n",(0,r.jsx)(n.p,{children:"To build the renderable Maya scene, we reference:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The renderable version of assets, containing shaders and associated UVs"}),"\n",(0,r.jsxs)(n.li,{children:["The ",(0,r.jsx)(n.code,{children:"onlyDeformed"})," (or ",(0,r.jsx)(n.code,{children:"_all"}),") Alembic from Tangerine for each asset"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"References in Maya render scene",src:t(9805).A+"",width:"831",height:"297"})}),"\n",(0,r.jsx)(n.p,{children:"Applying animation to our renderable meshes is done in two steps:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'Merging "transforms" Alembic onto the renderable hierarchy'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:'This allows transforming "set values" on moved transforms'}),"\n",(0,r.jsx)(n.li,{children:"Creates a connection between an Alembic node (transform file) and the animated transforms"}),"\n",(0,r.jsx)(n.li,{children:"This process can be repeated multiple times to update animation and set values changes"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Transform Curves Only",src:t(6026).A+"",width:"689",height:"415"})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Connecting meshes of the renderable hierarchy to the deformed ones from Tangerine using blend shapes"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"This allows handling potential differences in mesh hierarchy in a custom way (without using the AlembicImport algorithm directly)"}),"\n",(0,r.jsx)(n.li,{children:"Allows updating UVs on renderable meshes without affecting the animated parts"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Deformed Hierarchy Connected",src:t(9892).A+"",width:"1309",height:"773"})}),"\n",(0,r.jsxs)(a,{children:[(0,r.jsx)("summary",{children:"Command sample exports"}),(0,r.jsxs)(n.p,{children:["This sample code is based on the scene ",(0,r.jsx)(n.code,{children:"three_capy.shot"})," available in the demo package.\nYou should have your renderable assets referenced in the Maya scene before merging Alembic animation data."]}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"Renderable Assets Referenced in Maya",src:t(9668).A+"",width:"1396",height:"776"})}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def disconnect_custom_attributes(attributes, top_node):\n    """\n    It is necessary to unplug attribute connections in destination before tu plus an alembic\n    cause mergeAbc plug-in won\'t connect an attribute if there is a destination pluged in the attribute.\n    """\n    attributes_dict = {}\n    relative_nodes = cmds.listRelatives(top_node, ad=True, type="transform", f=True) or list()\n    relative_nodes = cmds.ls(relative_nodes, exactType="transform", l=True)\n\n    for node in relative_nodes:\n        for attribute in attributes:\n            if cmds.attributeQuery(attribute, n=node, ex=True):\n                connections = cmds.listConnections(node + "." + attribute, p=True, source=False)\n                if not connections:\n                    continue\n                attributes_dict.setdefault(node, []).append((attribute, connections))\n                for connection in connections:\n                    cmds.disconnectAttr(node + "." + attribute, connection)\n\n    return attributes_dict\n\ndef connect_custom_attributes(connections_dict):\n    """\n    We reconnecte attribut desination after plug alembic node\n    """\n    for node, connectionAttributeList in connectionsDict.items():\n        for attributeTuple in connectionAttributeList:\n            attribute, connections = attributeTuple\n            if not connections:\n                continue\n            for connection in connections:\n                # test if we have connections from reference\n                if not cmds.listConnections(connection, d=False, s=True):\n                    cmds.connectAttr(node + "." + attribute, connection)\n\n#\nalembicPath = "E:/TEMP/tangerine/Tangerine Demo 2025/api_samples/abc_export_usecase/prop_n01_yuzu_logo_transforms.abc"\nassetTopNode = "prop_n01_yuzu_logo:yuzu_logo"\nassetNamespace = "prop_n01_yuzu_logo"\n\n# AlembicImport plugin in maya does not know how to deal with attributs already connected, to merge a incoming alembic.\n# We desconnect it for merge, and reconnect them after. You can also use this to force a connection in your render scene, to drive values not from animated alembic from tangerine but another input.\n# searching for every custom attribute of the hierarchy.\nnodesWithCustomAttributs = (\ncmds.ls(\n    [assetNamespace + ":c_*", assetNamespace + ":geo_*", assetNamespace + ":grp_*"],\n    exactType="transform",\n    l=True,\n)\nor list()\n)\nnodesWithCustomAttributs.append(assetTopNode)\n\nattributes = ["visibility"]\nfor controler in nodesWithCustomAttributs:\n    customAttributes = cmds.listAttr(controler, ud=True) or list()\n    attributes.extend(customAttributes)\n\nattributesConnections = disconnectCustomAttributes(set(attributes), assetTopNode)\n\ncmd = \'AbcImport -mode import -connect "%s" "%s";\' % (assetTopNode, alembicPath)\nprint("executing command : %s" % cmd)\nalembicNode = mel.eval(cmd)\n\nconnectCustomAttributes(attributesConnections)\n'})}),(0,r.jsxs)(n.p,{children:["End up with connections made directly by AbcImport plugin\n",(0,r.jsx)(n.img,{alt:"gui merging_transformed_abc",src:t(3587).A+"",width:"1788",height:"904"})]})]}),"\n",(0,r.jsxs)(a,{children:[(0,r.jsx)("summary",{children:"Use blend shapes to transfer animation from Tangerine's Alembic to your renderable hierarchy."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'topNodeAbc = "abc_jb_deformed:jb"\nnamespaceAbc= topNodeAbc.split(":")[0]\nnamespace = "character_n01_jb"\nchildrenShapes = cmds.listRelatives(topNodeAbc, type=["mesh"], ad=True, f=True) or list()\nchildrenShapes = list(set(childrenShapes) - set(cmds.ls(childrenShapes, l=True, io=True)))\nchildrenMeshs = [x for x in childrenShapes if cmds.objectType(x) == "mesh"]\n\n\n# plug blendshape on original hierarchie\nfor shape in childrenShapes:\n    renderMesh = shape.replace(namespaceAbc + ":", namespace + ":")\n\n    if cmds.objExists(renderMesh) and cmds.objectType(shape) == "mesh":\n\n        # hack disconnect attribute in input\n        meshVisibility = cmds.getAttr(renderMesh + ".visibility")\n        inputConnections = (\n            cmds.listConnections(shape + ".visibility", destination=False, p=True, c=True) or list()\n        )\n        # If one of the meshes in blendshape is hidden, the command fail. So we show the meshes, and we hide them after blendshape\n\n        for x in range(0, len(inputConnections) - 1, 2):\n            cmds.disconnectAttr(inputConnections[x + 1], inputConnections[x])\n\n        # shape has to be visible to be deformable (specificity maya - alembic plugin)\n        if meshVisibility is False:\n            cmds.setAttr(shape + ".visibility", True)\n\n        # plug blendshape\n        try:\n            blendShapeName = cmds.blendShape(shape, renderMesh)[0]\n            cmds.blendShape(blendShapeName, edit=True, w=(0, 1))\n        except RuntimeError:\n            pass\n\n        if meshVisibility is False:\n            cmds.setAttr(shape + ".visibility", False)\n\n'})}),(0,r.jsx)(n.p,{children:"At the end, merge with blendshape creation creates a node graph similar to this one"}),(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"gui merging_deformed_abc_with_blendshape",src:t(1174).A+"",width:"1901",height:"747"})})]}),"\n",(0,r.jsx)(n.h2,{id:"add-preroll-and-postroll-before-export",children:"Add Preroll and Postroll Before Export"}),"\n",(0,r.jsx)(n.p,{children:"Some post-processing steps may require a preroll and postroll in the Alembic file."}),"\n",(0,r.jsxs)(n.p,{children:["When using the export command, you can choose a frame range that is different from the document's\n",(0,r.jsx)(n.a,{href:"./../tangerine_outputs/abc_exports#export-animations-to-alembics",children:"See bake documentation."})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'bake(\n    filename=outputPathLocal,\n    exclude_tag="do_not_bake",\n    included_spline_tag="do_bake",\n    roots=nodes,\n    write_uv=True,\n    document=document,\n    sub_samples=subsamples,\n    write_full_matrix=writeFullMatrix,\n    start_frame= -20,\n    end_frame= 50,\n)\n'})}),"\n",(0,r.jsx)(n.p,{children:"Usually, you will need to add keys in the preroll section to ensure correct positions, for example when using physics engines."}),"\n",(0,r.jsxs)(n.p,{children:["You can change the frame range for your document by setting ",(0,r.jsx)(n.code,{children:"document.start_frame"})," and ",(0,r.jsx)(n.code,{children:"document.end_frame"}),"."]}),"\n",(0,r.jsx)(n.p,{children:"If your animation is already validated and includes dynamics, the dynamics are calculated based on the document's first frame.\nChanging the frame range will affect these calculations."}),"\n",(0,r.jsx)(n.p,{children:"You can bake the dynamics before exporting to preserve the correct results."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:"from tang_core.callbacks import Callbacks\nfrom tang_core.document.get_document import get_document\nfrom mikan.meta_nodal.lib import dynamic\n\ndynamicControllers = []\n\ndocument = get_document()\n\nfor assetNode in document.root().get_children():\n    if not Callbacks().is_asset_node(document, assetNode):\n        continue\n    dynamicControllers += dynamic.filter_dynamic_controllers(\n        Callbacks().get_all_controllers_in_asset(assetNode)\n    )\n\nalreadyBakedControllers = dynamic.filter_baked_dynamic_controllers(dynamicControllers)\ndynamicControllers = [n for n in dynamicControllers if n not in alreadyBakedControllers]\n\nif dynamicControllers:\n    dynamic.bake_dynamic_controllers(dynamicControllers, document)\n"})})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>i});var a=t(6540);const r={},o=a.createContext(r);function s(e){const n=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(o.Provider,{value:n},e.children)}},9365:(e,n,t)=>{t.d(n,{A:()=>s});t(6540);var a=t(4164);const r={tabItem:"tabItem_Ymn6"};var o=t(4848);function s({children:e,hidden:n,className:t}){return(0,o.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,t),hidden:n,children:e})}},9668:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/build_scene_render_references-034e7a24bab9d390d1b977b14687311f.png"},9805:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/references_build_render_scene_three_capy-794b918794a9fc50f7857d50a0596c3e.png"},9892:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/deformed_hierarchy_abc_geometry_reading-725e967273ba03a9a2ab59fcaccaa397.png"}}]);